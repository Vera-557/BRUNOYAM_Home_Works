Вопросы:

Почему в java нет множественного наследования?
Ответ:
Классы могут наследовать поля, и если бы его было от нескольких родителей, было бы непонятно,
чьи поля и методы использовать. Интерфейсы же описывают только поведение,
и его можно безопасно "смешивать" из нескольких источников».

Зайдите в скомпилированный файл .class любого класса, где есть аннотация @Override.
Скомпилированные классы лежат в папке out/production. На картинке представлен пример класса Human,
у которого есть два переопределённых метода: toString() и equals().
Вопрос: почему над методами в скомпилированном классе нет аннотации @Override?

Ответ: Потому что компилятор уже съел эту инструкцию, этот файл скомпилирован.

3. Есть два интерфейса B и C. У каждого есть дефолтный метод default void print(),
как показано ниже. Также есть интерфейс А, который реализует оба этих интерфейса. И класс AImpl, который реализует интерфейс А.



Вопрос: что выведет aImpl.print(); ?

public interface B {
    default void print(){
		System.out.println("Я интерфейс В");
		}
}
public interface C {
    default void print(){
		System.out.println("Я интерфейс С");
	}
}
public interface A extends B, C {
}

public class AImpl implements A {

}

class Main {
    public static void main(String[] args) {
        AImpl aImpl = new AImpl();
        aImpl.print(); // что выведет метод ?
    }
}
Ответ: Здесь возникнет конфликт из-за дву одинаковых названий методов. Чтоб вызвать метод, нужно явно указать от кого именно.
Код не скомпилируется.